# 设计模式

## 总体理解
- 程序=模块+模块间的联系
- 设计模式的应用方面:
  - 优化模块的内部结构
  - 模块间的结构和交互
  - 模块的合理创建
- 设计模式的作用:
  - 提升程序性能
  - 提升代码可读性、简洁性

## 模块的封装
- 封装是模块化的基础,每个模块内部要完整、对外边界要清晰,高内聚、低耦合
- 模块通过接口调用
- 对模块的封装是设计模式的基本条件

## 面向对象-模块和对象
- 对象和模块,很多时候的含义是一样的,都是指实现一个功能的一部分代码
- 对象是面向对象编程思想中的概念,它是指一个拥有自身属性和方法的实体.模块则相对对象的概念要更加广泛一些,其内部的结构也会更加的复杂
- 这篇笔记中两个词语可能会混合使用,不必过多纠结使用哪个

## 设计原则
### 开闭原则
- 模块要对扩展开放,对修改关闭
### 单一职责原则
- 在一个抽象程度上,一个模块只做一件事
### 依赖倒置原则
- 上层模块不依赖于下层具体的模块,而依赖于抽象的功能
- 避免下层变动对上层产生剧烈影响.中间增加抽象层
### 接口隔离原则
- 不应该依赖不需要的接口
- 依赖应该建立在最小的接口上
### 最小知识原则
- 迪米特法则
- 让两个需要沟通的对象相互之间知道的越少越好
### 里式替换原则
- 任何使用父类的地方,都可以使用子类替换
- 子类完全继承父类的全部属性和方法

## 设计思想、理念
- `DRY` - dont repeat yourself - 时刻想方法合并代码中重复的部分
- 越简单越稳定
- 加入中间层、第三者模块,可以起到隔离、解耦、适配、调整接口、调整交互逻辑等作用

## 设计模式分类
### 创建型
- 工厂模式 - 由一个模块负责创建类似对象
- 单例模式 - 保证全局只有一个对象
- 建造者(组合)模式 - 组合出更复杂的对象
- 原型模式 - 对父级属性的直接访问和重写
### 组织结构型
- 外观模式 - 重新封装接口
- 适配器模式 - 适配双方接口
- 装饰者模式 - 扩展模块功能
- 享元/桥接模式 - 共享相似的代码
- 模板模式 - 抽象基类
### 交互行为型
- 中介者模式 - A<->B(中介者)<->C
- 观察者(发布-订阅)模式 - 由事件触发任务
- 职责链模式 - 对数据的一系列加工步骤形成链条
- 策略/状态模式 - 用策略/状态代替`if-else`判断
- 命令模式 - 通过配置一条"命令"进一步解耦调用和实现
### 其它技巧型
- 链模式 - 链式调用,每次都返回下一步要操作的对象
- 惰性/备忘录模式 - 记录先前的计算结果(低配的机器学习)
- 委托模式 - 让别人代替你收快递
- 等待者模式 - 等你们都回来再吃饭
- 数据访问模式 - 一个方便的数据管理器
- 迭代器模式 - 通过迭代器方法代替 for 循环

## 各模式详细介绍

### 工厂模式
- 由一个模块负责合理地创建类似对象
- 传入需求,返回对象

### 建造者模式
- 也叫组合模式
- 组合出更复杂的模块
- 被组合的模块之间本身没有耦合或者是低耦合的

### 单例模式
- 保证全局只有一个对象,避免重复创建的对象相互干扰
- 场景
  - 数据库访问
  - 路由控制

### 享元/桥接模式
- 共享相似的代码
- 减少重复代码 -> 提升可维护性
- 找出相似代码中的不同点,尽量小范围地抽象出来
- "用一个模特试穿一百套衣服"

### 模板模式
- 定义一系列操作的骨架,规范化和简化后面类似操作的内容
- 就是面向对象中的抽象基类
- 依赖于继承这一面向对象语言的特性
- 实践中,通常是组合大于继承,尽量使用组合代替继承解决问题,因为继承中父类会影响子类,这也是一种纵向耦合

### 适配器模式
- 加入中间层来匹配两端程序接口的差异
- 类比转接器

### 装饰者模式
- 在原先方法外多套一层进行扩展
- 场景 - 当方法需要修改,又不想或不便直接修改原方法

### 命令模式
- 通过配置一条"命令"进一步解耦调用和实现,使具体实现和调用方式互不干扰

### 观察者模式
- 也叫发布-订阅模式
- 场景:两个模块间不便于或无法轻松识别对方并直接沟通:事件绑定、异步操作
- 减少了模块间的直接沟通,降低模块间的耦合
- 观察者内部有一个任务中心
  - 发布时触发任务中心里对应的任务
  - 订阅时把任务放入任务中心

### 职责链模式
- 类似于工厂的流水线,把操作分割成一系列模块,每个模块只处理自己的事情,将任务进行传递
- 降低了任务发起者与多个任务处理者之间的耦合

### 访问者模式
- 解耦数据与数据的操作
- 类似于适配器模式,在数据和数据操作之上又加了一层适配器(访问者):
  操作 -> 数据
  ↓
  操作 -> 访问者 -> 数据
- 场景:
  - 当操作不便于灵活访问数据结构时
  - "大多情况下你不需要使用访问者模式，但是一旦需要使用它时那就真的需要使用了"

### 策略/状态模式
- 优化过多的`if-else`分支
- 状态模式和策略模式相似,是加入了状态管理的策略模式

### 外观模式
- 为系统重新封装接口,使系统接口更简单、清晰易用、高级、抽象

### 迭代器模式
- 通过迭代器方法代替 for 循环
- 不暴露数据内部结构的情况下,通过数据提供的迭代器方便地遍历数据
- 最典型 - `forEach()`

### 备忘录模式
- 记录先前的计算结果(低配的机器学习)
