# 设计模式

## 总体理解
- 程序=模块+模块间的联系
- 设计模式的应用方面:
  - 优化模块的内部结构
  - 模块间的结构和交互
  - 模块的合理创建
- 设计模式的作用:
  - 提升程序性能
  - 提升代码可读性、简洁性

## 模块的封装
- 封装是模块化的基础,每个模块内部要完整、对外边界要清晰,高内聚、低耦合
- 模块通过接口调用
- 对模块的封装是设计模式的基本条件

## 面向对象-模块和对象
- 对象和模块,很多时候的含义是一样的,都是指实现一个功能的一部分代码
- 对象是面向对象编程思想中的概念,它是指一个拥有自身属性和方法的实体.模块则相对对象的概念要更加广泛一些,其内部的结构也会更加的复杂
- 这篇笔记中两个词语可能会混合使用,不必过多纠结使用哪个

## 设计原则
### 开闭原则
- 模块要对扩展开放,对修改关闭
### 单一职责原则
- 在一个抽象程度上,一个模块只做一件事
### 依赖倒置原则
- 上层模块不依赖于下层具体的模块,而依赖于抽象的功能
- 避免下层变动对上层产生剧烈影响.中间增加抽象层
### 接口隔离原则
- 不应该依赖不需要的接口
- 依赖应该建立在最小的接口上
### 最小知识原则
- 迪米特法则
- 让两个需要沟通的对象相互之间知道的越少越好
### 里式替换原则
- 任何使用父类的地方,都可以使用子类替换
- 子类完全继承父类的全部属性和方法

## 设计思想、理念
- `DRY` - dont repeat yourself - 时刻想方法合并代码中重复的部分
- 越简单越稳定
- 加入中间层、第三者模块,可以起到隔离、解耦、适配、调整接口、调整交互逻辑等作用

## 设计模式分类
### 创建型
- 工厂模式 - 由一个模块负责创建类似对象
- 单例模式 - 保证全局只有一个对象
- 建造者(组合)模式 - 组合出更复杂的对象
- 原型模式 - 对父级属性的直接访问和重写
### 组织结构型
- 外观模式 - 重新封装接口
- 适配器模式 - 适配双方接口
- 装饰者模式 - 扩展模块功能
- 享元/桥接模式 - 共享相似的代码
- 模板模式 - 抽象基类
### 交互行为型
- 中介者模式 - A<->B(中介者)<->C
- 观察者(发布-订阅)模式 - 由事件触发任务
- 职责链模式 - 对数据的一系列加工步骤形成链条
- 策略/状态模式 - 用策略/状态代替`if-else`判断
- 命令模式 - 通过配置一条"命令"进一步解耦调用和实现
### 其它技巧型
- 链模式 - 链式调用,每次都返回下一步要操作的对象
- 惰性/备忘录模式 - 记录先前的计算结果(低配的机器学习)
- 委托模式 - 让别人代替你收快递
- 等待者模式 - 等你们都回来再吃饭
- 数据访问模式 - 一个方便的数据管理器
- 迭代器模式 - 通过迭代器方法代替 for 循环

## 各模式详细介绍

### 工厂模式
- 由一个模块负责合理地创建类似对象
- 传入需求,返回对象
> ### 简单示例
> - 最简单的工厂模式,通过策略模式实现的
> ```javascript
> const Factory = type => ({
>   type1: new Type1(),
>   type2: new Type2(),
>   type3: new Type3(),
> })[type];
> ```

### 建造者模式
- 也叫组合模式
- 组合出更复杂的模块
- 被组合的模块之间本身没有耦合或者是低耦合的
> ### 简单示例
> ```javascript
> function Cpnt1() {}
> function Cpnt2() {}
> function Cpnt3() {}
>
> function FinalComponent() {
>   this.Cpnt1=new Cpnt1()
>   this.Cpnt2=new Cpnt2()
>   this.Cpnt3=new Cpnt3()
> }
> ```

### 单例模式
- 保证全局只有一个对象,避免重复创建的对象相互干扰
- 场景
  - 数据库访问
  - 路由控制
> ### 简单示例1
> ```javascript
> function Single_Class(name) {
>   this.name=name
> }
> Single_Class.getInstance=function(name) {
>   if (this.instance) return this.instance
>   return this.instance=new Single_Class(name)
> }
> ```

> ### 简单示例 2
> ```javascript
> function store(){
>   if (store.install) {//通过自身的install属性来判断
>     return store.install
>   } else {
>     this.data={}
>     store.install=this//指向当前对象
>     }
> }
>
> console.log(new store()===new store())
> // true
> ```

### 享元/桥接模式
- 共享相似的代码
- 减少重复代码 -> 提升可维护性
- 找出相似代码中的不同点,把不同点尽量小范围地抽离出来单独处理
- "用一个模特试穿一百套衣服"
> ### 示例
> - jquery - extend()方法
> - `$.extend(obj)` / `$.extend(target,source)`
> - 如果有一个参数把`obj`拷贝到`$`自身上
> - 如果有两个参数把`source`拷贝到`target`上
> ```javascript
> $.extend(source)//source拷贝到$
> $.extend(target,source)//拷贝到target
>
> //非享元
> $.extend=function() {
>   if (arguments.length===1) {
>     for (let item in arguments[0]) {
>       this[item]=arguments[0][item]
>     }
>   } else {
>     for (let item in arguments[1]) {
>       arguments[0][item]=arguments[1][item]
>     }
>   }
> }
>
> //享元模式
> $.extend=function() {
>   let target,source
>   if (arguments.length===1) {
>     target=this
>     source=arguments[0]
>   } else {
>     target=arguments[0]
>     source=arguments[1]
>   }
>   for (let item in source) {
>     target[item]=source[item]
>   }
> }
> ```

### 模板模式
- 定义一系列操作的骨架,规范化和简化后面类似操作的内容
- 就是面向对象中的抽象基类
- 依赖于继承这一面向对象语言的特性
- 实践中,通常是组合大于继承,尽量使用组合代替继承解决问题,因为继承中父类会影响子类,这也是一种纵向耦合

### 适配器模式
- 加入中间层来匹配两端程序接口的差异
- 类比转接器
> ### 简单示例1
> - 在一个项目中,都通过`log(str)`来打印到控制台
>   而环境中并没有`log()`方法
> ```javascript
> let log=(()=>global.console.log)()
> log(15)
> ```

> ### 简单示例 2
> - 要把下层依赖的框架从`A`改为`B`
> - 两个框架十分相似,但有少数几个方法不同
> ```javascript
> //以前的接口
> A.c()
> A.o()
> //现在的接口
> B.css()
> B.on()
>
> //先把框架A整个替换为B
> window.A=B
> //对(名字)不同的部分进行适配
> A.c=function(){
>   return B.css.apply(this,arguments)
> }
> A.o=function(){
>   return B.on.apply(this,arguments)
> }
> ```

> ### 示例 3 - 参数适配
> - 当方法传入的参数比较多时进行适配
>   `fn({xx:xx,xxx:xxx,xxxx:xxxx})`
> - 很多框架都会加入的参数适配操作
> ```javascript
> function fn(config) {
>   //对参数进行适配的部分
>   let _default={
>     arg1:'xxx',
>     arg2:'xxx',
>     arg3:'xxx',
>     arg4:'xxx'
>   }
>   for (let item in _default) {
>     _default[item]=config[item]||_default[item]
>   }
>   //函数后续的功能实现
> }
> ```

### 装饰者模式
- 在原先方法外多套一层进行扩展
- 场景 - 当方法需要修改,又不想或不便直接修改原方法
- 举例
  - python 装饰器
> ### 简单示例
> ```javascript
> //原方法
> function fn() {}
>
> //包装(装饰)方法
> function my_fn(){
>   fn()
>     //扩展的功能
> }
>
> //使用包装后的方法
> my_fn()
> ```

> ### 示例 2 - 扩展dom元素事件
> ```javascript
> //原方法
> dom.onclick=function(){
>   console.log(1)
> }
>
> //非装饰者模式
> //直接对原方法进行修改
> dom.onclick=function(){
>   console.log(1)
>   console.log(2)
> }
>
> //装饰者模式
> //先做一个专门扩展点击事件适配工厂
> let decorator=function(dom,fn) {
>   if (typeof dom.onclick==='function') {
>     let _old=dom.onclick
>     dom.onclick=()=>{
>       _old()
>       fn()
>     }
>   }
> }
> //对dom元素进行扩展
> decorator(document.getElementById('dom1'),()=>console.log(2))
> ```

### 命令模式
- 通过配置一条"命令"进一步解耦调用和实现,使具体实现和调用方式互不干扰

> ### 示例 - JS 沙箱执行命令
> ```javascript
> let fn=(()=>{
>   let action={
>     //具体实现
>   }
>
>   //返回一个解析命令的对外接口
>   return commond=>{/*解析命令*/}
> })()
>
> fn(/*命令*/)
> ```

> ### 示例 - canvas绘图命令
>  - 以对象作为命令
>  - 传入多条命令
> ```javascript
> //未使用命令模式
> let myCanvas=function(){}
>
> myCanvas.prototype.drawCircle=function(config){}
> myCanvas.prototype.drawRect=function(config){}
>
> let drawer=new myCanvas()
> drawer.drawRect({/*配置参数*/})
> drawer.drawRect({/*配置参数*/})
> drawer.drawRect({/*配置参数*/})
> drawer.drawCircle({/*配置参数*/})
> drawer.drawCircle({/*配置参数*/})
> drawer.drawCircle({/*配置参数*/})
> drawer.drawCircle({/*配置参数*/})
>
>
> //命令模式
> let drawer=(()=>{
>   let action={//绘图方法的实现
>     drawCircle:function(config){/*实现*/},
>     drawRect:function(config){/*实现*/}
>   }
>   return function excute(commander){
>     //解析并执行绘图命令
>     commander.forEach(item=>{
>       action[item.command](item.config)
>     })
>   }
> })()
>
> drawer([
>   {command:'drawRect',config:{}},
>   {command:'drawRect',config:{}},
>   {command:'drawRect',config:{}},
>   {command:'drawCircle',config:{}},
>   {command:'drawCircle',config:{}},
>   {command:'drawCircle',config:{}},
>   {command:'drawCircle',config:{}}
> ])
> ```

### 观察者模式
- 也叫发布-订阅模式
- 场景:两个模块间不便于或无法轻松识别对方并直接沟通:事件绑定、异步操作
- 减少了模块间的直接沟通,降低模块间的耦合
- 观察者内部有一个任务中心
  - 发布时触发任务中心里对应的任务
  - 订阅时把任务放入任务中心
- 观察者模式不仅能实现模块间交互,还能实现模块的自循环调用

> ### 示例 - JS极简实现
> ```javascript
> function observer() {
>   this.message={}
> }
>
> observer.prototype={
>   regist:function(type,fn){
>     this.message[type]=fn
>   },
>   trigger:function(type){
>     this.message[type]()
>   },
>   remove:function(type){
>     this.message[type]=null
>   }
> }
> ```

> ### 示例 - JS 简单实现
> ```javascript
> class Observer {
>   constructor() {
>     this.events={}//事件中心
>   }
>   publish(eventName,...args) {//发布=>调用事件中心中对应的函数
>     if (this.events[eventName])
>       this.events[eventName].forEach(cb=>cb.apply(this,args))
>   }
>   subscribe(eventName,callback) {//订阅=>向事件中心中添加事件
>     if (this.events[eventName]) {
>       this.events[eventName].push(callback)
>     } else {
>       this.events[eventName]=[callback]
>     }
>   }
>   unSubscribe(eventName,callback) {//取消订阅
>     if (events[eventName])
>       events[eventName]=events[eventName].filter(cb=>cb!==callback)
>   }
> }
> ```

### 职责链模式
- 类似于工厂的流水线,把操作分割成一系列模块,每个模块只处理自己的事情,将任务进行传递
- 降低了任务发起者与多个任务处理者之间的耦合

> ### 示例 - 函数实现
> ```javascript
> function mode1(){}
> function mode2(){}
> function mode3(){}
>
> let data,result
> _result=mode3(mode2(mode1(data)))
> ```

### 访问者模式
- 解耦数据与数据的操作
- 类似于适配器模式,在数据和数据操作之上又加了一层适配器(访问者):
  操作 -> 数据
  ↓
  操作 -> 访问者 -> 数据
- 场景:
  - 当操作不便于灵活访问数据结构时
  - "大多情况下你不需要使用访问者模式，但是一旦需要使用它时那就真的需要使用了"

> ### 示例
> ```javascript
> //非访问者模式
> //数据
> let data=[]
> //数据的操作
> function operate(){}
>
> //访问者模式
> //数据
> let data=[]
> //数据的操作
> function operate(){}
> //访问者
> function visitor(){
>   operate()
> }
> ```

> ### 示例 - 不同角色关心不同数据
> - 公司有一个财务报表
> - 财务关心支出和收入
> - 老板关心盈利情况
> ```javascript
> //数据-财务报表
> function report(){
>   this.income=''
>   this.cost=''
>   this.profit=''
> }
>
> //老板
> function boss() {}
> boss.prototype={get:function(data){}}
>
> //财务
> function account(){}
> account.prototype={get:function(num1,num2){}}
>
> //访问者
> //采用策略模式
> function visitor(data,role){
>   let handle={
>     boss:data=>role.get(data.profit),
>     account:data=>role.get(data.income,data.cost)
>   }
>   //获取角色的类型
>   handle[role.constructor.name](data)
> }
>
> //老板看
> visitor(new report(),new boss())
> //财务看
> visitor(new report(),new account())
> ```

### 策略/状态模式
- 优化过多的`if-else`分支
- 状态模式和策略模式相似,是加入了状态管理的策略模式

### 外观模式
- 为系统重新封装接口,使系统接口更简单、清晰易用、高级、抽象

### 迭代器模式
- 通过迭代器方法代替 for 循环
- 不暴露数据内部结构的情况下,通过数据提供的迭代器方便地遍历数据
- 最典型的迭代器 - `forEach()`

### 备忘录模式
- 记录先前的计算结果(低配的机器学习)
